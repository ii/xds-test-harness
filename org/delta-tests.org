#+TITLE: Delta Tests
#+PROPERTY: header-args :results output :noweb yes

* Introduction
This org file documents the creation of new tests for the delta variant of the xDS protocol.
This is a milestone for the 0.5 conformance suite,a s covered in the [[https://docs.google.com/document/d/17E3k4fGJedVISCudrW4Kgzf89gvIIhAdZnJmo6pMVlA/edit][Statement of Work]].

This is not intended to be all delta tests, or even the exemplary, ideal tests.
This is to explore what a test wsould look like so that, with feedback, we can
turn them into the exampleary, ideal tests that all our future delta tests
spring from.

In addition. I want to start doing some organization of the repo to more closely
match the project structure outlined in our [[https://github.com/ii/xds-test-harness/pull/9][Design Document]]. So will be creating
a new feature file and, potentially, adding the new steps for the runner in a =steps= directory.

* Our Tests
As we are already working on some subscription tests, I think it makes sense to
do subscription features for Delta so that we can merge the SoTW and Delta
subscription scenarios into a single feature file. It will also be easier to get
help from the rest of the team if our head is in the same, general place.

So some good FEatures would be:
- [Delta] Subscribing to subset of resources, only getting that subset.
- [Delta] Subscribing to an additional resource.
- [Delta] When only 1 of that subset changes, getting the appropriatel scoped response.

* Diary
** Research some delta
#+begin_quote
So, the four variants of the xDS transport protocol are:
    State of the World (Basic xDS): SotW, separate gRPC stream for each resource type
    Incremental xDS: incremental, separate gRPC stream for each resource type
    Aggregated Discovery Service (ADS): SotW, aggregate stream for all resource types
    Incremental ADS: incremental, aggregate stream for all resource types
#+end_quote

For this starting test, we can do Incremental xDS, and not worry agout the ADS just yet.

#+begin_quote
For the non-aggregated protocol variants, there is a separate RPC service for
each resource type. Each of these RPC services can provide a method for each of
the SotW and Incremental protocol variants. Here are the RPC services and
methods for each resource type:

Cluster: Cluster Discovery Service (CDS) - SotW: ClusterDiscoveryService.StreamClusters - Incremental: ClusterDiscoveryService.DeltaClusters
#+end_quote

using the go-control-plane as the target, we will not need to setup any sort of configuration beforehand, and can easily move from a SoTW test to a Delta test...we'd just switch the endpoint for our stream.

#+begin_quote
Each xDS stream begins with a DiscoveryRequest from the client, which specifies
the list of resources to subscribe to, the type URL corresponding to the
subscribed resources, the node identifier, and an optional resource type
instance version indicating the most recent version of the resource type that
the client has already seen (see ACK/NACK and resource type instance version for
details).

For all of the incremental methods, the request type is DeltaDiscoveryRequest
and the response type is DeltaDiscoveryResponse.
#+end_quote

We'll initiate the stream like we've done with other tests: with a discovery request specified in yaml. It'll be be structured slightly differently, though, thus its different type.

#+begin_quote
xDS requests allow the client to specify a set of resource names as a hint to the server about which resources the client is interested in. In the SotW protocol variants, this is done via the resource_names specified in the DiscoveryRequest; in the incremental protocol variants, this is done via the resource_names_subscribe and resource_names_unsubscribe fields in the DeltaDiscoveryRequest.
#+end_quote

#+begin_quote
In the incremental protocol variants, the server sends each resource in its own response. This means that if the server has previously sent 100 resources and only one of them has changed, it may send a response containing only the changed resource; it does not need to resend the 99 resources that have not changed, and the client must not delete the unchanged resources.
#+end_quote

So in one of our tests, we'll subscribe to 3 of 5 clusters:
- *foo*
- *bar*
- *baz*
- echo
- fun

Then, we'll change =foo='s connection timeout. The client should receive a
discovery response that has just =foo=, but it /could also/ contain =bar= and
=baz=. This means we will want our "then we should receive a response" to be
flexible. The test would only fail if we got =echo= and =fun= in the response,
as we never subscribed to them.

We could have it say something like:
: Then we receive a response containing only resources from this list: "foo", "bar", "baz"
however, this wouldn't check whether we, for some reason, changed foo and got a response showing only bar and baz.

I think we'd want something like:
: Then we receive a respone containing "foo"
: And the response does not contain "echo"  or "fun"

This would be cleaned up to best use gherkin's features, but the key thing is we
can't just match on ideal discovery response samples. We have to throw in a bit
more logic in our parser.
** Setup Feature file
All tests will go in our subscription feature file, and we will tag them with @delta.
Then we can tell godog to /just/ do SoTW tests if an
implementation does not yet have delta.

#+NAME: Subscription Feature
#+begin_src feature :tangle (ii/workdir+ "features/subscribe.feature")
Feature: A client can subscribe and unsubcribe from an arbitary amount of resources, and receive updates for only the resources they're subscribed to
  Background:
    Given "adapter" is reachable via gRPC
    And "target" is reachable via gRPC

  <<Subscribe to subset of clusters>>
#+end_src
** Write "Subscribe to subset of clusters"
I want to subscribe to 3 out of 5 clusters, but not have to describe the full discovery request i am sending.

#+NAME: Subscribe to subset of clusters
#+begin_src feature
@delta
Scenario: I can subscribe to a subset of resources
  Given a target setup with the following resources:
  ```
  clusters:
  - foo
  - bar
  - baz
  - echo
  - fun
  ```
  When I subscribe to CDS for these clusters:
  ```
  - foo
  - bar
  - baz
  ```
  Then I get a response containing these resources:
  ```
  clusters:
  - foo
  - bar
  - baz
  ```
  And the response does not contain these resources:
  ```
  clusters:
  - echo
  - fun
  ```
#+end_src

After tangling this file, I should be able to run godog for /just/ delta tests, and see some function signatures.

#+begin_src shell :dir (ii/workdir+ "")
godog --tags=@delta
#+end_src

#+RESULTS:
#+begin_example
Feature: A client can subscribe and unsubcribe from an arbitary amount of resources, and receive updates for only the resources they're subscribed to

  Background:
    Given "adapter" is reachable via gRPC              # acknack_test.go:174 -> *Runner
    And "target" is reachable via gRPC                 # acknack_test.go:174 -> *Runner

  Scenario: I can subscribe to a subset of resources   # features/subscribe.feature:7
    Given a target setup with the following resources:
      ```
      clusters:
      - foo
      - bar
      - baz
      - echo
      - fun
      ```
    When I subscribe to CDS for these clusters:
      ```
      - foo
      - bar
      - baz
      ```
    Then I get a response containing these resources:
      ```
      clusters:
      - foo
      - bar
      - baz
      ```
    And the response does not contain these resources:
      ```
      clusters:
      - echo
      - fun
      ```

1 scenarios (1 undefined)
6 steps (2 passed, 4 undefined)
4.427516ms

You can implement step definitions for undefined steps with these snippets:

func aTargetSetupWithTheFollowingResources(arg1 *messages.PickleStepArgument_PickleDocString) error {
	return godog.ErrPending
}

func iGetAResponseContainingTheseResources(arg1 *messages.PickleStepArgument_PickleDocString) error {
	return godog.ErrPending
}

func iSubscribeToCDSForTheseClusters(arg1 *messages.PickleStepArgument_PickleDocString) error {
	return godog.ErrPending
}

func theResponseDoesNotContainTheseResources(arg1 *messages.PickleStepArgument_PickleDocString) error {
	return godog.ErrPending
}

func InitializeScenario(ctx *godog.ScenarioContext) {
	ctx.Step(`^a target setup with the following resources:$`, aTargetSetupWithTheFollowingResources)
	ctx.Step(`^I get a response containing these resources:$`, iGetAResponseContainingTheseResources)
	ctx.Step(`^I subscribe to CDS for these clusters:$`, iSubscribeToCDSForTheseClusters)
	ctx.Step(`^the response does not contain these resources:$`, theResponseDoesNotContainTheseResources)
}

#+end_example

Sweet as! And now to implement this test.
